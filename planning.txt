4th of November, 2023

We were able to get some basic data transfer between a local server and a gamemaker client. I have a few thoughts about how to proceed with this project. Firstly I'm tempted to make some sort of very tiny MMO. Something where all you can do is wander around and... some sort of super simple game mechanic. Maybe pick up items? Talk to people? I think doing a whole battle system might be too much.

I want to finally deal with the concept of accounts, and secure password storage. It looks like gamemaker is capable of doing http requests. 

Used this guide to setup typescript for node.js
https://khalilstemmler.com/blogs/typescript/node-starter-project/


5th of November, 2023

We've got the client and the server talking to eachother. I'm still stuck on what sort of game to make. I like the idea of something that doesn't require a ton of state synching since that's a lot to accomplish before Thursday. Oh I should've mentioned I have this goal of something playable to present by Thursday.

Fixed some bugs where browser based exports weren't using a web socket connection. That involved adding a web socket server but I don't think it's a big deal. This was important because now we should be able to export as a web browser game, and anyone can play easily.

I'm still thinking about my mini MMO idea, and I have one idea for how to handle state. What if the game was actually defined and run in the server, and the client is simply a remote controller and renderer. The game could state coule be something totally serializable. Something that could be stored in JSON. The server could send updates to the player whenever the game world state changed, such as an enemy or player moving, or whatever. And the client sends controller input to the server. This will probably end up feeling really laggy, but at the very least it would be consistent. And might be a good way to do a "first go" at this.

We'd have to figure out a way to render the game world from json data. No more creating rooms right in game maker. Maybe that could be tomorrow's project. Create a json level that can be sent from the server to the client, and a way for the client to render it. And if we're feeling really ambitious, add some form of controllable player.

I've got a node server running, and I'm trying to send data to it through `http_request`. I've tested it with Postman and the server correctly receives requests and prints whatever's in the body of the request. It also receives requests from my GameMaker client, but it doesn't print the body correctly. 

I was able to almost completely fix the http_request invisible body bug. Firstly, the server didn't have CORS configured, so the browser didn't trust anything it was getting back from the server. And since it sends a preflight request before sending the "real" request, the preflight would fail and the real request never made it to the server. Also the mothod for my request was GET. The method POST is what's designed to have a body, and changing the gamemaker method to POST seems to have fixed it in almost all cases. 

For some reason it's still not working on GX Games export in chrome? Very annoying, but since it works fine on every other export I'm tempted to not worry about this yet. We'll come back to this. For now let's think about how we want state to work in game.

I have an idea to get multiple boxes moving around. First, let's imagine the entire state of the game is serializeable so that it can be easily shipped over the web. And for now our only game entities are players, and their entire state will be this:

{
	player_id: string,
	position_x: real,
	position_y: real,
	player_color: color.
}

We could store these player objects in a struct, where the key for each player is their id. If there were 3 players in the game, the entire game state could look like this:

{
	40ed49ac-2181-4bf9-982b-032e7508fd86: {
		player_id: 40ed49ac-2181-4bf9-982b-032e7508fd86,
		position_x: 87,
		position_y: 12,
		player_color: blue,
	},
	9f9132af-26b5-4c3a-bca4-632e010c9595: {
		player_id: 9f9132af-26b5-4c3a-bca4-632e010c9595,
		position_x: 99,
		position_y: 4,
		player_color: blue,
	},
	a1ed9157-9c15-49a0-a08d-43bec6eafff7: {
		player_id: a1ed9157-9c15-49a0-a08d-43bec6eafff7,
		position_x: 32,
		position_y: 9,
		player_color: blue,
	},
}

Whenever the game state on the server updates, we could ship it to all players (probably using our TCP socket network?). When the clients receive this information they'll simply overwrite whatever internal gamestate they have, and replace it with this one. And so on the draw cycle each client will see an updated game state.

But the players need to be able to move themselves around. So when a player changes their position, we'll send a message to the server to update their gamestate by the correct values. I think there are issues with lage, and relying on the server to tak input and update positions, but let's start with this. Once that's working we can try doing fancy stuff where we don't overwrite the players own state when pulling from the server.

Right now I have it rigged up so hitting an http endpoint will create the player. I want the player to exist in the world for as long as the client is running. So as soon as they quit the player should be removed. The only way I have to check that is on error or connection end for the socket connections. But since the http request and the socket connections don't know about eachother, how will the socket connection know which player id to remove and update? I almost wonder if we shouldn't even use the http request yet.

I want to keep the http request around because I know we'll want to use that in the future. Actually how about this, we'll leave it so that only tcp/web socket connection error or end can remove players. And we'll simply not start the tcp/websocket connection until the client has gotten their player id. And once the socket connection is established, we'll have the client send the server the player id it got earlier, and from there we'll be able to connect the socket connection with a player id.

Is there no way to gracefully close a socket connection in gamemaker??


6th of November, 2023

We just added player movement, which correctly updates the state of all other connected clients. Let's take a break then assess what to do next.

Ah crap. I think we never needed to make two socket servers. It looks like the windows client can totally connect to a web socket server.


7th of November, 2023

I had an idea for a treasure hunt game. The entire game could be 1 room with dozens of interacteable objects. Opening the application puts you into a queue for games. Once enough people are ready the server will start a "game" where a certain number of interacteable objects will be randomly chosen to contain treasure. Once a player has interacted with all 5 reasure containing interacts, they win!

I think this is a good idea because it doesn't require any state interact between the players, and it won't be too hard to let the server decide which interacts contain data. In fact we could just give the interacts  string names, and the server could randomly choose which names are the interacts. That works well because the clients to tell the server a player is checking an interact, and then respond with yes/no for that interact. So the clients will never know which interacts are treasures until they find one.

I also like this idea because it'll force us to think through the concept of organizing a "game". The client will have to understand the different states of queueing for a game and being in a game. And the server will have to juggle players getting ready for the game. I think this is an interesting puzzle to solve, and worth our time.

To get started, let's pretend the game is simpler. We'll randomly spawn a box somewhere in the gameworld, and the first player to touch it wins. We'll do 2 players games to start since that'll be easier for testing.

I suppose when a player loads the app, they'll immediately join the queue. Perhaps we could add a queue value to the player state. Additionally we could add a "game_id" value to the player state to indicate what game they're in once a game has started.

I suppose the server, when players are added from the starting the app, could immediately assign them queue values. And the server at certain points will assess how many players are in the queue, and if there are enough to start a game, start a game. That would involve generating a game_id and assigning it to those players.

But how would the server manage state for players in a game? We obviously don't need to update the position of players that are in a queue. And of course players in different game_ids don't need to know about players in other games.

These are the questions we need to think through tomorrow.

Ooh, one more thought. I wonder if we could turn this into a type racer clone instead??


(later that day)

Just for now, let's leave the position and color values in the player state. But we definitely need to add a game_id field to the player. I think we could also add a "ready" field, which the client could set to indicate that the player is ready to be queued. 

I was thinking of how to define a queued player, but it just occured to me we shouldn't add players to the queue until they've clicked ready.

Oh, perhaps instead of a "ready" field we just have the "queue" field. This would be their spot in the queue. If their value is -1 they're simply not queued, and the server is waiting for the client to send a "ready" event. When that happens the server will add them to the queue.

Yes, players have a "queue" and "game_id". They start out with both values as -1. We'll setup the client so players can click "ready", which will make a request to the server to queue them. The server will assign them a queue value. Players will be sorted in the server based on queue value and once enough players are queue, the server will take the top x number of players from the queue and assign them a game_id. I think we could also unassign them queue values at this point. 

The server will also need a way to run the games. When creating a game_id the server will also need to add this id to an array or something to keep track of existing games. Oh wait. Perhaps Games would be objects themselves which contain an id, and the players involved in that game. 

I suppose we could simply rig up the clients so they send events with a game_id associated during gameplay. So when a player state changes, if it's associated with a game, the server knows which other player connections to send gamestate updates to.


Hmmm... I have an idea for testing. Let's just let the clients send a "win" event to the server. So for now instead of coding an actual game with a win condition, this'll let us test out games starting and ending.

Ok I've got it. Add game_id and queue fields to the players. Add functionality to the server so it can send gamestate to clients indicating if they are waiting to ready, queued, or in-game. Setup the server so it can create games, and send that information to players. And add client update events to tell the server someone's won a game, and make the server able to respond to that to close the game and reset queue/ready data for involved players. 

Ah, important book keeping note. Let's not call it game_id. Let's call it match_id. And let's start calling them "matches". Although the word "game" is totally appropriate, we've already named a lot of our infrastructure "game". And I think the term "match" much more immediately and accurately describes exactly what it is.

I'm looking over how we send data to the players. Originally I had this weird callback system because we had different socket connections. But now I think we could simply associate a connection with a player. However, it's clear to me that we want to tailor the exact state sent to players based on current game state. Perhaps we'll still associate a socket connection with a player, but we'll create a function specifically for sending state using that socket instead of ever really referencing it in the game logic.

As I'm writing more of the code for this, I'm tempted to say we should just remove the http server. There's no real reason for it, and I think it's over-complicating the socket stuff.

8th of November, 2023

Still just trying to code the state plan I outlined above. I hurt my back which has also hurt my focus, so my pace hasn't been great. There's not a huge rush though. We'll just do what we can.

I just realized letting the player keep track of its own place in queue, and what match it's in, is stupid. let's create an actual queue array that we'll add players to.

I think we should also get rid of the concept of events from the client side. The server basically dictates the entire player state.


9th of November, 2023

We were able to add a match queue, and matches. But I don't like that there isn't a ready screen, or a results screen. I think once the system finds a game it should display a sort of game found screen. Perhaps we won't let the player manually click any "ready" button or whatever, and just force into the game. But we definitely need a results screen so the player can understand who won, and decide what game state they want to go to next. 

I think we'll send a match start time to the clients. And the clients will manually do a sort of count down based on that given start time. But actually playing the match and the count down won't be actual separate state values.

We also need to let players leave the match separately. One person may want to immediately re-queue, but the other may want to just sit in the results screen. I think someday we should let players go straight from game to re-queue, but for now let's just have them go back to title screen on exit results.

We've hit a possibly major issue. GameMaker may not have a way to get the current time in micro seconds the same way Javascript does. Without this we won't have a way to synch time of our clients with server.

(later that day)

Yup, from what I see there isn't an easy way to get the exact time in GameMaker. I was thinking it'd be cool if the server gave a match start time to both clients, and they could use that value to count down 3 seconds or so to start the match. But without that solid anchor this seems like a wild goose chase.

Let's just have the clients manually count down to game start themselves once their state changes. This ultimately means one of the clients has an unfair advantage because they'll get the state update sooner, but whatever. It won't be by too much time, and this is my first networking project, we'll allow mistakes.


